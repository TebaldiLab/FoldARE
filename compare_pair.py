#!/usr/bin/env python3

"""
compare_pair.py

Generate N structures from two chosen ensemble tools (EternaFold, RNAsubopt,
RNAstructure, or LinearFold), then compute and visualize how they agree:

 1. Produce an interactive N×N Plotly heatmap (HTML) of all‐vs‐all pairwise
    consensus scores between the two ensembles.
 2. Compute and plot positional Shannon entropy (HTML), showing variability
    at each nucleotide position across the two sets.
 3. Compute and plot positional consensus score (HTML), the fraction of
    structures agreeing at each position.
 4. Compute and plot the fraction of unpaired ('.') nucleotides at each position.
 5. Optionally, extract the top-N best pairs of structures by average consensus and
    write them to a CSV.

Usage example:
    python compare_pair.py \
      -s myseq.fasta \
      -e1 E -e2 V \
      -n 20 \
      --top_n 5 \
      -o compare_pair_results \
      -c config.yaml \
"""
import argparse
import tempfile
import os
import shutil
from pathlib import Path
from datetime import datetime
from collections import Counter

from ruamel.yaml import YAML
import utils

letter_map = {'E': 'EternaFold',
                'V': 'RNASubopt',
                'R': 'RNAStructure',
                'L': 'LinearFold',
                'V6': 'RNASubopt_m6A',
                'R6': 'RNAStructure_m6A'}

ENSEMBLE_COLORS = {
    'E': 'brown',
    'V': 'red',
    'R': '#bfb6db',  # a lighter purple
    'L': 'green',
    'V6': 'lightcoral',
    'R6': 'violet'
}

def load_config(path: str):
    yaml = YAML(typ="safe")
    with open(path) as fh:
        return yaml.load(fh)

def load_sequence(path_or_seq: str) -> str:
    """If `path_or_seq` is a file, read FASTA (ignore headers), else return as-is."""
    p = Path(path_or_seq)
    if p.exists():
        seq = []
        for line in p.read_text().splitlines():
            if line.startswith(">"): continue
            seq.append(line.strip())
        return "".join(seq)
    else:
        return path_or_seq.strip()

def generate_ensemble(letter: str, seq: str, out_db: str, ens_n: int, cfg: dict):
    """
    Generate an ensemble of structures using method `letter` (E, V, R, L),
    writing to out_db. Uses the executable & params from cfg.
    """
    m6A = False
    tool_name = letter_map[letter]
    if tool_name == "RNASubopt_m6A":
        tool_name = "RNASubopt"
        m6A = True
    elif tool_name == "RNAStructure_m6A":
        tool_name = "RNAStructure"
        m6A = True
    tool_cfg  = cfg[tool_name]
    exe        = tool_cfg['executable']
    params     = tool_cfg.get('params', {})
    params['m6A'] = False
    if m6A:
        params['m6A'] = True

    # write raw results to a temp file
    tmp_db = out_db + ".tmp"

    if letter == 'V' or letter == 'V6':  # RNAsubopt
        desired = ens_n
        utils.RNASubopt(
            seq_file=seq,
            out_file=tmp_db,
            executable=exe,
            n_struc=ens_n,
            m6A=params.get('m6A'),
            method=params.get('method')
        )
        full_list = utils.extract_ensemble(tmp_db)
        print(len(full_list), "structures generated by RNAsubopt")
        if len(full_list) > desired:
            trimmed = full_list[:desired]
            with open(out_db, 'w') as fh:
                fh.write("\n".join(trimmed) + "\n")
            return trimmed

    elif letter == 'E':  # EternaFold
        utils.EternaFold(
            seq_file=seq,
            out_file=tmp_db,
            mode="sample",
            executable=exe,
            eternaFold_params=params.get('eternaFold_params'),
            eternaFold_params_shape=params.get('eternaFold_params_shape'),
            nsamples=ens_n 
        )

    elif letter == 'R' or letter == 'R6':  # RNAstructure → warning if < N
        utils.RNAStructure(
            seq_file=seq,
            out_file=tmp_db,
            executable=exe,
            m6A=params.get('m6A'),
            maxm=params.get('maxm')
        )
        full_list = utils.extract_ensemble(tmp_db)
        if len(full_list) < ens_n:
            print(f"WARNING: RNAStructure produced only {len(full_list)} structures (requested {ens_n})")
        trimmed = full_list[:ens_n]
        with open(out_db, 'w') as fh:
            fh.write("\n".join(trimmed) + "\n")
        return trimmed

    elif letter == 'L':  # LinearFold → iterative‐delta
        desired       = ens_n
        current_delta = params.get('delta', 5.0)
        while True:
            utils.LinearFold(
                seq_file=seq,
                out_file=tmp_db,
                mode="ensemble",
                executable=exe,
                delta=current_delta
            )
            full_list = utils.extract_ensemble(tmp_db)
            if len(full_list) >= desired:
                break
            current_delta += 1.0

        trimmed = full_list[:desired]
        with open(out_db, 'w') as fh:
            fh.write("\n".join(trimmed) + "\n")
        return trimmed

    else:
        raise ValueError(f"Unknown ensemble letter: {letter}")

    # Extract the dot-bracket lines and trim to top_n
    full_list = utils.extract_ensemble(tmp_db)
    trimmed   = full_list[:ens_n]
    with open(out_db, 'w') as fh:
        fh.write("\n".join(trimmed) + "\n")
    return trimmed

from datetime import datetime
from pathlib import Path

def write_output_summary_compare_pair(
    out_dir: Path,
    base: str,
    seq_label: str,
    e1: str,
    e2: str,
    ens_n: int,
    top_n: int | None,
    scoring_method: str
):
    """
    Create <base>_compare_pair_summary.txt describing outputs of compare_pair.py.
    """
    p = out_dir / f"{base}_compare_{e1}_{e2}_pair_summary.txt"
    lines = []
    lines.append("compare_pair.py – Output Summary\n")
    lines.append("="*56 + "\n\n")
    lines.append(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    lines.append(f"Sequence: {seq_label}\n")
    lines.append(f"Ensembler 1: {e1}\n")
    lines.append(f"Ensembler 2: {e2}\n")
    lines.append(f"Ensemble size per method (N): {ens_n}\n")
    lines.append(f"Scoring method: {scoring_method}\n")
    if top_n:
        lines.append(f"Top-N pairs reported: {top_n}\n")
    lines.append(f"Output folder: {out_dir.resolve()}\n\n")

    lines.append("[Generated files]\n")
    lines.append(f"  - {base}_compare_{e1}_{e2}_heatmap.html               : N×N similarity heatmap (interactive)\n")
    lines.append(f"  - {base}_compare_{e1}_{e2}_positional_entropy.html   : per-position Shannon entropy, both methods overlaid (interactive)\n")
    lines.append(f"  - {base}_compare_{e1}_{e2}_structural_consensus.html : per-position consensus, both methods overlaid (interactive)\n")
    lines.append(f"  - {base}_compare_{e1}_{e2}_fraction_ssRNA.html      : per-position fraction of '.' (unpaired), both methods overlaid (interactive)\n")

    if top_n:
        lines.append(f"  - {base}_compare_{e1}_{e2}_best_pairs.csv            : top-N structure pairs by similarity\n")
    lines.append("\nNotes:\n")
    lines.append("  • Heatmap hover shows pairwise similarity and truncated structures.\n")
    lines.append("  • Entropy/consensus plots are chunked over rows for long sequences; hover for nt and per-symbol fractions.\n")

    with open(p, "w") as fh:
        fh.writelines(lines)
    print(f"Summary file written: {p}")


def main():
    p = argparse.ArgumentParser(
        description="Consensus heatmap between two ensemble methods"
    )
    p.add_argument("-s","--sequence",  required=True,
                help="Path to a FASTA (or raw sequence)")
    p.add_argument("-e1","--ensembler1",   required=True, choices=['E','V','R','L', 'V6', 'R6'],
                help="First ensemble: E (EternaFold), V (RNAsubopt), R (RNAstructure), L (LinearFold), V6 (ViennaRNA_m6A), R6 (RNAStructure_m6A)")
    p.add_argument("-e2","--ensembler2",   required=True, choices=['E','V','R','L', 'V6', 'R6'],
                help="Second ensemble method")
    p.add_argument("-n","--ens_n",      type=int,
                help="Number of structures to sample from each ensemble (defaults to global_ensemble_size)")
    p.add_argument("--top_n",           type=int,
                help="Number of best structures (highest average consensus) to return in a separate file")
    p.add_argument("-o", "--output_folder", default="compare_pair_results",
                help="Output folder")
    p.add_argument("-c","--config",     default="config.yaml",
                help="YAML configuration file")
    args = p.parse_args()

    # ensure output folder exists (minimal change)
    Path(args.output_folder).mkdir(parents=True, exist_ok=True)

    # ─── load config & env ─────────────────────────────────────────────────────
    CFG = load_config(args.config)
    env = CFG.get("environment", {})
    if env.get("data_tables"):
        os.environ["DATAPATH"] = os.path.abspath(env["data_tables"])
    if env.get("threads") is not None:
        os.environ["OMP_NUM_THREADS"] = str(env["threads"])

    # ─── determine scoring method ───────────────────────────────────────────────
    scoring_method = CFG.get("scoring", {}).get("method", "identity")
    similarity_func = utils.get_similarity_func(scoring_method)

    # ─── determine ensemble‐size (ens_n) and best‐structures count (top_n) ─────────
    ens_n = args.ens_n if args.ens_n is not None else CFG.get("global_ensemble_size", 20)
    top_n = args.top_n  # may be None

    seq = load_sequence(args.sequence)
    e1, e2 = args.ensembler1, args.ensembler2

    base = Path(args.sequence).stem

    tmpdir = Path(tempfile.mkdtemp(prefix="enscmp_"))
    try:
        out1 = str(tmpdir / f"ens1_{e1}.db")
        out2 = str(tmpdir / f"ens2_{e2}.db")

        structs1 = generate_ensemble(e1, args.sequence, out1, ens_n, CFG)
        structs2 = generate_ensemble(e2, args.sequence, out2, ens_n, CFG)

        # --- build consensus matrix & hover text ---
        import plotly.graph_objects as go
        z, text = [], []
        rows = [f"{e1}{ens_n-i}" for i in range(ens_n)]
        cols = [f"{e2}{j+1}" for j in range(ens_n)]
        pair_scores = []  

        for i, s1 in enumerate(structs1):
            zrow, trow = [], []
            for j, s2 in enumerate(structs2):
                score = similarity_func(s1, s2)
                zrow.append(score)
                pair_scores.append((rows[i], cols[j], s1, s2, score))
                hover = (
                    f"similarity_score ({scoring_method}) = {score:.3f}<br>"
                    f"seq = {seq[:70]}{'/' if len(seq)>70 else ''}<br>"
                    f"{rows[i][0] + '0' + rows[i][1:] if int(rows[i][1:]) < 10 else rows[i]} – {s1[:70]}{'/' if len(s1)>70 else ''}<br>"
                    f"{cols[j][0] + '0' + cols[j][1:] if int(cols[j][1:]) < 10 else cols[j]} – {s2[:70]}{'/' if len(s2)>70 else ''}"
                )
                trow.append(hover)
            z.append(zrow)
            text.append(trow)

        fig = go.Figure(data=go.Heatmap(
            z=z, x=cols, y=rows,
            hoverinfo="text", text=text,
            colorbar=dict(title="Similarity"),
            hoverlabel = dict(
            font=dict(
                family="Courier New",
                color="black",
                size=14
            ),
            bgcolor="white"
        ),
        #font to monospace
        colorscale='Blues',
            textfont=dict(family="Courier New", size=12)
        ))
        fig.update_layout(
            title=f"Similarity heatmap: {letter_map[e1]} vs {letter_map[e2]} (top {ens_n})",
            xaxis_title=f"{e2} structures",
            yaxis_title=f"{e1} structures"
            # ensure square cells
        )
        fig.update_xaxes(tickangle=-45, tickmode='array', tickvals=cols)
        fig.update_yaxes(tickmode='array', tickvals=rows)
        fig.update_layout(
            width=1000, height=1000,
            margin=dict(l=50, r=50, t=50, b=50),
            autosize=False
        )
        fig.update_layout(font_family="Courier New")

        fig.write_html(os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_heatmap.html"), auto_open=False)
        print("Wrote heatmap to", os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_heatmap.html"))

        # ─── Positional entropy & consensus ───────────────────────────────────────────
        # Compute global entropy for each ensemble
        size1 = len(structs1[0])
        entropy_list1 = [
            utils.shannon_math([s[i] for s in structs1], unit="shannon")
            for i in range(size1)
        ]
        global_ent1 = sum(entropy_list1) / size1

        # Ensemble 2 average positional entropy
        size2 = len(structs2[0])
        entropy_list2 = [
            utils.shannon_math([s[i] for s in structs2], unit="shannon")
            for i in range(size2)
        ]
        global_ent2 = sum(entropy_list2) / size2

        print(
            f"Average positional Shannon entropy: "
            f"{letter_map[e1]} = {global_ent1:.3f}, "
            f"{letter_map[e2]} = {global_ent2:.3f}"
        )

        # Compute per-position entropy, consensus, and per-symbol frequencies
        seq_len = len(seq)
        pos_ent1 = []
        pos_ent2 = []
        pos_cons1 = []
        pos_cons2 = []
        
        freq1 = {".": [], "(": [], ")": []}
        freq2 = {".": [], "(": [], ")": []}

        for i in range(seq_len):
            col1 = [s[i] for s in structs1]
            col2 = [s[i] for s in structs2]
            # entropy
            pos_ent1.append(utils.shannon_math(col1, unit="shannon"))
            pos_ent2.append(utils.shannon_math(col2, unit="shannon"))
            # consensus = fraction of the most common symbol
            c1 = Counter(col1)
            c2 = Counter(col2)
            pos_cons1.append(max(c1.values()) / len(col1))
            pos_cons2.append(max(c2.values()) / len(col2))
            
            for sym in (".","(",")"):
                freq1[sym].append(c1.get(sym, 0) / len(col1))
                freq2[sym].append(c2.get(sym, 0) / len(col2))

        # Split long sequences into chunks of ~50 positions per row
        from math import ceil
        from plotly.subplots import make_subplots
        import plotly.graph_objects as go

        nrows = 4
        chunk_size = ceil(seq_len / nrows)
        # Each row's plot width scales with the chunk_size 
        min_px_per_base = 10 
        row_width_px = max(chunk_size * min_px_per_base, 800)

        # ─── Positional entropy plot (adaptive rows, scrollable width) ───────────────
        fig_e = make_subplots(
            rows=nrows, cols=1,
            shared_xaxes=False,
            subplot_titles=[
                f"Positions {r*chunk_size+1}-{min((r+1)*chunk_size, seq_len)}"
                for r in range(nrows)
            ]
        )

        for r in range(nrows):
            start = r * chunk_size + 1
            end   = min((r+1) * chunk_size, seq_len)
            xs    = list(range(start + 1, end + 1))
            
            fig_e.add_trace(
                go.Scatter(
                    x=xs, y=pos_ent1[start:end],
                    mode='lines+markers',
                    name=f"{letter_map[e1]} entropy, (row {r+1})",
                    line=dict(color=ENSEMBLE_COLORS[e1]),
                    marker=dict(color=ENSEMBLE_COLORS[e1]),
                    hovertext=[
                        (
                            f"pos={'0' + str(i) if i < 10 else str(i)}"
                            f"<br>nt={seq[i-1]}"
                            f"<br>ent={pos_ent1[i-1]:.3f}"
                            f"<br>(={freq1['('][i-1]:.3f} )={freq1[')'][i-1]:.3f} .={freq1['.'][i-1]:.3f}"
                        )
                        for i in xs
                    ],
                ),
                row=r+1, col=1
            )

            fig_e.add_trace(
                go.Scatter(
                    x=xs, y=pos_ent2[start:end],
                    mode='lines+markers',
                    name=f"{letter_map[e2]} entropy, (row {r+1})",
                    line=dict(color=ENSEMBLE_COLORS[e2]),
                    marker=dict(color=ENSEMBLE_COLORS[e2]),
                    hovertext=[
                        (
                            f"pos={'0' + str(i) if i < 10 else str(i)}"
                            f"<br>nt={seq[i-1]}"
                            f"<br>ent={pos_ent2[i-1]:.3f}"
                            f"<br>(={freq2['('][i-1]:.3f} )={freq2[')'][i-1]:.3f} .={freq2['.'][i-1]:.3f}"
                        )
                        for i in xs
                    ],
                ),
                row=r+1, col=1
            )

            fig_e.update_xaxes(range=[start - 0.5, end + 1], row=r + 1, col=1)
            fig_e.update_yaxes(range=[0, max(max(pos_ent1[start:end]), max(pos_ent2[start:end]), 1) * 1.05], row=r + 1, col=1)

        fig_e.update_layout(
            title_text=(
                f"Positional Shannon Entropy "
                f"(global: {letter_map[e1]}={global_ent1:.3f}, {letter_map[e2]}={global_ent2:.3f})"
            ),
            font_family="Courier New",
            width=max(row_width_px, 1000),   # this makes each row horizontally scrollable in the browser
            height= max(700, 235 * nrows),  # scale height by number of rows
            margin=dict(l=40, r=20, t=180, b=40),
            legend=dict(orientation="h", yanchor="bottom", y=1.03, xanchor="left", x=0)
        )

        fig_e.write_html(os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_positional_entropy.html"), auto_open=False)
        print("Wrote positional entropy plot to", os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_positional_entropy.html"))

        # ─── Positional consensus plot (adaptive rows, scrollable width) ─────────────
        fig_c = make_subplots(
            rows=nrows, cols=1,
            shared_xaxes=False,
            subplot_titles=[
                f"Positions {r*chunk_size+1}-{min((r+1)*chunk_size, seq_len)}"
                for r in range(nrows)
            ]
        )

        for r in range(nrows):
            start = r * chunk_size + 1
            end   = min((r+1) * chunk_size, seq_len)
            xs    = list(range(start + 1, end + 1))

            fig_c.add_trace(
                go.Scatter(
                    x=xs, y=pos_cons1[start:end],
                    mode='lines+markers',
                    name=f"{letter_map[e1]} consensus, (row {r+1})",
                    line=dict(color=ENSEMBLE_COLORS[e1]),
                    marker=dict(color=ENSEMBLE_COLORS[e1]),
                    hovertext=[
                        (
                            f"pos={'0' + str(i) if i < 10 else str(i)}"
                            f"<br>nt={seq[i-1]}"
                            f"<br>cons={pos_cons1[i-1]:.3f}"
                            f"<br>(={freq1['('][i-1]:.3f} )={freq1[')'][i-1]:.3f} .={freq1['.'][i-1]:.3f}"
                        )
                        for i in xs
                    ],
                ),
                row=r+1, col=1
            )

            fig_c.add_trace(
                go.Scatter(
                    x=xs, y=pos_cons2[start:end],
                    mode='lines+markers',
                    name=f"{letter_map[e2]} consensus, (row {r+1})",
                    line=dict(color=ENSEMBLE_COLORS[e2]),
                    marker=dict(color=ENSEMBLE_COLORS[e2]),
                    hovertext=[
                        (
                            f"pos={'0' + str(i) if i < 10 else str(i)}"
                            f"<br>nt={seq[i-1]}"
                            f"<br>cons={pos_cons2[i-1]:.3f}"
                            f"<br>(={freq2['('][i-1]:.3f} )={freq2[')'][i-1]:.3f} .={freq2['.'][i-1]:.3f}"
                        )
                        for i in xs
                    ],
                ),
                row=r+1, col=1
            )

            fig_c.update_xaxes(range=[start - 0.5, end + 1], row=r + 1, col=1)
            fig_c.update_yaxes(range=[0, 1.05], row=r + 1, col=1)

        fig_c.update_layout(
            title_text="Structural Consensus Score",
            font_family="Courier New",
            width=max(row_width_px, 1000),   # horizontally scrollable
            height= max(700, 235 * nrows),
            margin=dict(l=60, r=20, t=180, b=40),
            legend=dict(orientation="h", yanchor="bottom", y=1.03, xanchor="left", x=0)
        )

        fig_c.write_html(os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_structural_consensus.html"), auto_open=False)
        print("Wrote structural consensus plot to", os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_structural_consensus.html"))

        # ─── Per-position fraction of unpaired '.' (adaptive rows) ─────────────
        pos_ss1 = freq1["."]  # length = seq_len
        pos_ss2 = freq2["."]

        fig_ss = make_subplots(
            rows=nrows, cols=1,
            shared_xaxes=False,
            subplot_titles=[
                f"Positions {r*chunk_size+1}-{min((r+1)*chunk_size, seq_len)}"
                for r in range(nrows)
            ]
        )

        for r in range(nrows):
            start = r * chunk_size + 1
            end   = min((r+1) * chunk_size, seq_len)
            xs    = list(range(start + 1, end + 1))

            # ensembler 1
            fig_ss.add_trace(
                go.Scatter(
                    x=xs, y=pos_ss1[start:end],
                    mode='lines+markers',
                    name=f"{letter_map[e1]} unpaired '.' (row {r+1})",
                    line=dict(color=ENSEMBLE_COLORS[e1]),
                    marker=dict(color=ENSEMBLE_COLORS[e1]),
                    hovertext=[
                        (
                            f"pos={'0' + str(i) if i < 10 else str(i)}"
                            f"<br>nt={seq[i-1]}"
                            f"<br>frac '.'={pos_ss1[i-1]:.3f}"
                            f"<br>(={freq1['('][i-1]:.3f} )={freq1[')'][i-1]:.3f} .={freq1['.'][i-1]:.3f}"
                        )
                        for i in xs
                    ],
                ),
                row=r+1, col=1
            )

            # ensembler 2
            fig_ss.add_trace(
                go.Scatter(
                    x=xs, y=pos_ss2[start:end],
                    mode='lines+markers',
                    name=f"{letter_map[e2]} unpaired '.' (row {r+1})",
                    line=dict(color=ENSEMBLE_COLORS[e2]),
                    marker=dict(color=ENSEMBLE_COLORS[e2]),
                    hovertext=[
                        (
                            f"pos={'0' + str(i) if i < 10 else str(i)}"
                            f"<br>nt={seq[i-1]}"
                            f"<br>frac '.'={pos_ss2[i-1]:.3f}"
                            f"<br>(={freq2['('][i-1]:.3f} )={freq2[')'][i-1]:.3f} .={freq2['.'][i-1]:.3f}"
                        )
                        for i in xs
                    ],
                ),
                row=r+1, col=1
            )

            fig_ss.update_xaxes(range=[start - 0.5, end + 1], row=r + 1, col=1)
            fig_ss.update_yaxes(range=[0, 1.05], row=r + 1, col=1)

        fig_ss.update_layout(
            title_text="Per-position fraction of unpaired nucleotides ('.')",
            xaxis_title="Position",
            yaxis_title="Fraction '.'",
            font_family="Courier New",
            width=max(row_width_px, 1000),   # horizontally scrollable like others
            height=max(700, 235 * nrows),
            margin=dict(l=60, r=20, t=180, b=40),
            legend=dict(orientation="h", yanchor="bottom", y=1.03, xanchor="left", x=0)
        )

        ss_html = os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_fraction_ssRNA.html")
        fig_ss.write_html(ss_html, auto_open=False)
        print("Wrote fraction-unpaired plot to", ss_html)

        if top_n:
            # Sort all pairs by consensus score, descending
            pair_scores.sort(key=lambda x: x[4], reverse=True)

            # Take top_n best pairs (no duplicates)
            best_pairs = pair_scores[:min(top_n, len(pair_scores))]
            
            # Write to CSV
            best_file = os.path.join(args.output_folder, f"{base}_compare_pair_{e1}_{e2}_best_pairs.csv")
            with open(best_file, 'w') as fh:
                fh.write(f"{e1}_index,{e2}_index,{e1}_structure,{e2}_structure,similarity_score\n")
                for i, j, s1, s2, score in best_pairs:
                    fh.write(f"{i[0] + '0' + i[1:] if int(i[1:]) < 10 else i},{j[0] + '0' + j[1:] if int(j[1:]) < 10 else j},{s1},{s2},{score:.3f}\n")

            print(f"Wrote top {len(best_pairs)} best structure pairs to {best_file}")

        # --- write summary file
        write_output_summary_compare_pair(
            out_dir=Path(args.output_folder),
            base=base,
            seq_label=args.sequence,
            e1=e1, e2=e2,
            ens_n=ens_n,
            top_n=top_n,
            scoring_method=scoring_method
        )

    finally:
        shutil.rmtree(tmpdir)

    

if __name__ == "__main__":
    main()
